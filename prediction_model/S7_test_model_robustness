import numpy as np
from torch.utils.data import Dataset, DataLoader
import torch
from torch.utils.data.sampler import SubsetRandomSampler
import torch.nn as nn
import pickle
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import os
import json
import time
import matplotlib.cm as cm
import random

plt.rcParams.update({"mathtext.default": "regular"})
plt.rcParams["font.family"] = "Times New Roman"
plt.rcParams["figure.dpi"] = 300

# %% data preprocessing


class dataload(Dataset):
    def __init__(self, root):
        xy = np.load(root)
        mus_set_path = "mus_set.npy"
        mua_set_path = "mua_set.npy"
        mus_set = np.load(mus_set_path)
        mua_set = np.load(mua_set_path)

        max_mus = np.repeat(np.max(mus_set, axis=0)[:3], 20)
        max_mua = np.repeat(np.max(mua_set, axis=0)[:3], 20)
        bloodConc_max = np.array([174])
        x_max = torch.from_numpy(np.concatenate(
            (max_mus, max_mua, bloodConc_max)))

        min_mus = np.repeat(np.min(mus_set, axis=0)[:3], 20)
        min_mua = np.repeat(np.min(mua_set, axis=0)[:3], 20)
        bloodConc_min = np.array([138])
        x_min = torch.from_numpy(np.concatenate(
            (min_mus, min_mua, bloodConc_min)))

        idx = [i for i in range(282, 302)] + [i for i in range(322, 342)] + [i for i in range(362, 382)] + [
            i for i in range(402, 422)] + [i for i in range(41, 101)] + [i for i in range(141, 201)] + [241]
        # x = xy[:,idx]
        # x[:,:40] = x[:,:40]*10**5
        # x[:,40:201] = (x[:,40:201] - x_min.numpy()) / (x_max.numpy() - x_min.numpy())
        # x[:,201:221] = x[:,201:221]*10**8
        # x[:,241:261] = x[:,241:261]*10**8
        # x[:,281:301] = x[:,281:301]*10**8
        # x[:,321:341] = x[:,321:341]*10**8

        # idx = [i for i in range(282,302)] + [i for i in range(322,342)] + [i for i in range(362,382)] + [i for i in range(402,422)]
        # self.x = torch.from_numpy(xy[:,262:422])
        # self.x[:,0:20] =  self.x[:,0:20]*10**8
        # self.x[:,40:60] = self.x[:,40:60]*10**8
        # self.x[:,80:100] = self.x[:,80:100]*10**8
        # self.x[:,120:140] = self.x[:,120:140]*10**8

        self.x = torch.from_numpy(xy[:, idx])  # small value :0, 10^-10
        # self.x[:,0:160] = self.x[:,0:160]*10**8
        # self.x[:,0:20] =  self.x[:,0:20]*10**8
        # self.x[:,40:60] = self.x[:,40:60]*10**8
        # self.x[:,80:100] = self.x[:,80:100]*10**8
        # self.x[:,120:140] = self.x[:,120:140]*10**8

        self.x[:, 80:201] = (self.x[:, 80:201] - x_min) / (x_max - x_min)
        # self.x[:,201:221] = self.x[:,201:221]*10**8
        # self.x[:,241:261] = self.x[:,241:261]*10**8
        # self.x[:,281:301] = self.x[:,281:301]*10**8
        # self.x[:,321:341] = self.x[:,321:341]*10**8
        self.y = torch.from_numpy(xy[:, 40])
        self.parameters = torch.from_numpy(xy[:, 41:])
        self.n_samples = xy.shape[0]

    def __getitem__(self, index):

        return self.x[index], self.y[index], self.parameters[index]

    def __len__(self):

        return self.n_samples

# %% model1


class ANN(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(201, 256),
            nn.ReLU(),
            # nn.Linear(512, 256),
            # nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 1)
        )

    def forward(self, x):
        return self.net(x)


def pred():
    if not os.path.isdir(os.path.join("pic", f"{local_time}")):
        os.mkdir(os.path.join("pic", f"{local_time}"))

    model.eval()

    tissue = ['Reflectance',
              'skin $\mu_s$', 'fat $\mu_s$', 'muscle $\mu_s$',
              'skin $\mu_a$', 'fat $\mu_a$', 'muscle $\mu_a$',]
    error_test = 1 + 0.01*np.linspace(-10, 10, 21).astype(int)

    plot_error_test = np.linspace(-10, 10, 21).astype(int)

    # for t_idx, t in enumerate(tissue):
    #     mean = []
    #     std = []
    #     for factor in error_test:

    #         error = []
    #         error_dict = {}

    #         SO2 = [(i-70)/100 for i in range(40,91,1)]
    #         # SO2.pop(SO2.index(0.0))
    #         # SO2_text = [f'{(i-70)}%' for i in range(40,91,1)]
    #         for s in SO2:
    #             error_dict[str(round(100*s))] = []

    #         for batch_idx, (data,target, parameters) in enumerate(train_loader):
    #             data,target = data.to(torch.float32).cuda(), target.to(torch.float32).cuda()

    #             if t == 'Reflectance':
    #                 data[:,:80] = data[:,:80]*factor
    #             else:
    #                 data[:,80+t_idx*20:80+(t_idx+1)*20] = data[:,80+t_idx*20:80+(t_idx+1)*20]*factor #skin_mus

    #             output = model(data)
    #             output = output.view(-1)
    #             output = output.detach().cpu().numpy()
    #             target = target.detach().cpu().numpy()
    #             # y = torch.exp(-output).detach().cpu().numpy()
    #             # x = torch.exp(-target).detach().cpu().numpy()
    #             error += list(100*(torch.abs((torch.tensor(output)-torch.tensor(target)))).numpy()) #Absolute error
    #             # e = torch.abs((torch.tensor(output)-torch.tensor(target))).max().item()
    #             # if e*100 > max_error:
    #             #     max_error = e*100
    #             # # error += torch.sqrt(torch.square((torch.tensor(output)-torch.tensor(target))).mean()).item()
    #             # for i in range(target.shape[0]):
    #             #     error_dict[str(round(100*target[i]))].append(np.square(100*output[i]-100*target[i]))
    #             #     true_SO2.append(round(100*target[i]))
    #             #     pred_SO2.append(100*output[i])
    #             #     error_SO2.append(100*(output[i]-target[i]))

    #             # plt.plot(target,output, 'r.', markersize=5)
    #             # plt.plot(target,target,'b')

    #         error = np.array(error)
    #         mean.append(np.mean(error))
    #         std.append(np.std(error))

    #     # mean = np.array(mean)
    #     # std = np.array(std)
    #     plt.plot(plot_error_test, mean)
    #     plt.plot(plot_error_test, mean, 'bo')
    #     # plt.fill_between(error_test, mean+std, mean-std,alpha=0.1)
    #     # plt.ylim([0, max(mean+std)])

    #     plt.title(f"{t} variation abs error \nmean error:{min(mean):.2f}% std:{np.std(mean):.2f}%")
    #     # plt.xticks(SO2, SO2_text)
    #     # plt.yticks(SO2, SO2_text)
    #     plt.xlabel(f"variation of {t} (%)")
    #     plt.ylabel("Absolute Error(%)")
    #     plt.savefig(os.path.join("pic",f"{local_time}",f"{t}_variation_AbsError.png"))
    #     plt.show()

    error_test = 1 + 0.01*np.linspace(0, 10, 11).astype(int)
    plot_error_test = np.linspace(0, 10, 11).astype(int)
    tissue = ['Optical Parameters']
    change_idx = [i for i in range(80)] + [i for i in range(80, 80+120)]
    for t_idx, t in enumerate(tissue):
        print(t)

        # mean_mean = np.zeros((10,21))
        # std_std = np.zeros((10,21))
        # for iter_idx in range(10):
        mean = []
        std = []
        for factor in error_test:

            error = []
            error_dict = {}

            SO2 = [(i-70)/100 for i in range(40, 91, 1)]
            SO2.pop(SO2.index(0.0))
            SO2_text = [f'{(i-70)}%' for i in range(40, 91, 1)]

            for s in SO2:
                error_dict[str(round(100*s))] = []

            for batch_idx, (data, target, parameters) in enumerate(train_loader):
                data, target = data.to(torch.float32).cuda(
                ), target.to(torch.float32).cuda()

                noise = np.ones((data.shape[0], data.shape[1]))
                for n_idx in range(data.shape[0]):
                    if t == 'Reflectance':
                        # noise[n_idx][0:20] = 1 + (random.random()*2-1)*(factor-1)
                        # noise[n_idx][20:40] = 1 + (random.random()*2-1)*(factor-1)
                        # noise[n_idx][40:60] = 1 + (random.random()*2-1)*(factor-1)
                        # noise[n_idx][60:80] = 1 + (random.random()*2-1)*(factor-1)
                        for i in range(80):
                            noise[n_idx][i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                    else:
                        for i in range(20):
                            noise[n_idx][80+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][100+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][120+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][140+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][160+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][180+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                noise = torch.from_numpy(noise).to(torch.float32).cuda()

                # if t == 'Reflectance':
                #     data[:,:80] = data[:,:80]*noise
                # else:
                #     data[:,80+t_idx*20:80+(t_idx+1)*20] = data[:,80+t_idx*20:80+(t_idx+1)*20]*noise #skin_mus

                data = data*noise

                output = model(data)
                output = output.view(-1)
                output = output.detach().cpu().numpy()
                target = target.detach().cpu().numpy()
                # y = torch.exp(-output).detach().cpu().numpy()
                # x = torch.exp(-target).detach().cpu().numpy()
                # Absolute error
                error += list(100*(torch.abs((torch.tensor(output) -
                              torch.tensor(target)))).numpy())
                # e = torch.abs((torch.tensor(output)-torch.tensor(target))).max().item()
                # if e*100 > max_error:
                #     max_error = e*100
                # # error += torch.sqrt(torch.square((torch.tensor(output)-torch.tensor(target))).mean()).item()
                # for i in range(target.shape[0]):
                #     error_dict[str(round(100*target[i]))].append(np.square(100*output[i]-100*target[i]))
                #     true_SO2.append(round(100*target[i]))
                #     pred_SO2.append(100*output[i])
                #     error_SO2.append(100*(output[i]-target[i]))

                # plt.plot(target,output, 'r.', markersize=5)
                # plt.plot(target,target,'b')

            error = np.array(error)
            mean.append(np.mean(error))
            std.append(np.std(error))
            # mean_mean[iter_idx] = np.mean(error)
        # mean = np.mean(mean_mean, axis=0)
        # std = np.std(mean_mean, axis=0)
        # mean = np.array(mean)
        # std = np.array(std)
        plt.plot(plot_error_test, mean,
                 label=f'{t}', color=cm.rainbow(t_idx/len(tissue)))
        plt.plot(plot_error_test, mean, 'o',
                 color=cm.rainbow(t_idx/len(tissue)))
        # plt.fill_between(plot_error_test, np.array(mean)+np.array(std), np.array(mean)-np.array(std),alpha=0.1, color=cm.rainbow(t_idx/len(tissue)))
        # plt.ylim([0, max(mean+std)])

    # plt.title("parameter variation abs error with fixed noise")
    plt.title("parameter variation abs error with random noise")
    # plt.xticks(SO2, SO2_text)
    # plt.yticks(SO2, SO2_text)
    # plt.xlabel("parameter with fixed noised (%)")
    plt.xlabel("parameter with random noise (%)")
    plt.ylabel("Absolute Error (%)")
    plt.legend()
    plt.savefig(os.path.join("pic", f"{local_time}", "Optical Parameters.png"))
    plt.show()
    ###############
    error_test = 1 + 0.01*np.linspace(0, 10, 11).astype(int)
    plot_error_test = np.linspace(0, 10, 11).astype(int)
    tissue = ['Reflectance', 'Optical Parameters']
    change_idx = [i for i in range(80)] + [i for i in range(80, 80+120)]
    for t_idx, t in enumerate(tissue):
        print(t)

        # mean_mean = np.zeros((10,21))
        # std_std = np.zeros((10,21))
        # for iter_idx in range(10):
        mean = []
        std = []
        for factor in error_test:

            error = []
            error_dict = {}

            SO2 = [(i-70)/100 for i in range(40, 91, 1)]
            SO2.pop(SO2.index(0.0))
            SO2_text = [f'{(i-70)}%' for i in range(40, 91, 1)]

            for s in SO2:
                error_dict[str(round(100*s))] = []

            for batch_idx, (data, target, parameters) in enumerate(train_loader):
                data, target = data.to(torch.float32).cuda(
                ), target.to(torch.float32).cuda()

                noise = np.ones((data.shape[0], data.shape[1]))
                for n_idx in range(data.shape[0]):
                    if t == 'Reflectance':
                        # noise[n_idx][0:20] = 1 + (random.random()*2-1)*(factor-1)
                        # noise[n_idx][20:40] = 1 + (random.random()*2-1)*(factor-1)
                        # noise[n_idx][40:60] = 1 + (random.random()*2-1)*(factor-1)
                        # noise[n_idx][60:80] = 1 + (random.random()*2-1)*(factor-1)
                        for i in range(80):
                            noise[n_idx][i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                    else:
                        for i in range(20):
                            noise[n_idx][80+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][100+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][120+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][140+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][160+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                            noise[n_idx][180+i] = 1 + \
                                (random.random()*2-1)*(factor-1)
                noise = torch.from_numpy(noise).to(torch.float32).cuda()

                # if t == 'Reflectance':
                #     data[:,:80] = data[:,:80]*noise
                # else:
                #     data[:,80+t_idx*20:80+(t_idx+1)*20] = data[:,80+t_idx*20:80+(t_idx+1)*20]*noise #skin_mus

                data = data*noise

                output = model(data)
                output = output.view(-1)
                output = output.detach().cpu().numpy()
                target = target.detach().cpu().numpy()
                # y = torch.exp(-output).detach().cpu().numpy()
                # x = torch.exp(-target).detach().cpu().numpy()
                # Absolute error
                error += list(100*(torch.abs((torch.tensor(output) -
                              torch.tensor(target)))).numpy())
                # e = torch.abs((torch.tensor(output)-torch.tensor(target))).max().item()
                # if e*100 > max_error:
                #     max_error = e*100
                # # error += torch.sqrt(torch.square((torch.tensor(output)-torch.tensor(target))).mean()).item()
                # for i in range(target.shape[0]):
                #     error_dict[str(round(100*target[i]))].append(np.square(100*output[i]-100*target[i]))
                #     true_SO2.append(round(100*target[i]))
                #     pred_SO2.append(100*output[i])
                #     error_SO2.append(100*(output[i]-target[i]))

                # plt.plot(target,output, 'r.', markersize=5)
                # plt.plot(target,target,'b')

            error = np.array(error)
            mean.append(np.mean(error))
            std.append(np.std(error))
            # mean_mean[iter_idx] = np.mean(error)
        # mean = np.mean(mean_mean, axis=0)
        # std = np.std(mean_mean, axis=0)
        # mean = np.array(mean)
        # std = np.array(std)
        plt.plot(plot_error_test, mean,
                 label=f'{t}', color=cm.rainbow(t_idx/len(tissue)))
        plt.plot(plot_error_test, mean, 'o',
                 color=cm.rainbow(t_idx/len(tissue)))
        # plt.fill_between(plot_error_test, np.array(mean)+np.array(std), np.array(mean)-np.array(std),alpha=0.1, color=cm.rainbow(t_idx/len(tissue)))
        # plt.ylim([0, max(mean+std)])

    # plt.title("parameter variation abs error with fixed noise")
    plt.title("parameter variation abs error with random noise")
    # plt.xticks(SO2, SO2_text)
    # plt.yticks(SO2, SO2_text)
    # plt.xlabel("parameter with fixed noised (%)")
    plt.xlabel("parameter with random noise (%)")
    plt.ylabel("Absolute Error (%)")
    plt.legend()
    plt.savefig(os.path.join("pic", f"{local_time}", "OP_Reflectance.png"))
    plt.show()

    ######################
    error_test = 1 + 0.01*np.linspace(-10, 10, 21).astype(int)

    plot_error_test = np.linspace(-10, 10, 21).astype(int)
    tissue = ['Reflectance',
              'skin $\mu_s$', 'fat $\mu_s$', 'muscle $\mu_s$',
              'skin $\mu_a$', 'fat $\mu_a$', 'muscle $\mu_a$',]
    change_idx = [i for i in range(80)] + [i for i in range(80, 80+120)]
    for t_idx, t in enumerate(tissue):
        print(t)

        # mean_mean = np.zeros((10,21))
        # std_std = np.zeros((10,21))
        # for iter_idx in range(10):
        mean = []
        std = []
        for factor in error_test:

            error = []
            error_dict = {}

            SO2 = [(i-70)/100 for i in range(40, 91, 1)]
            SO2.pop(SO2.index(0.0))
            SO2_text = [f'{(i-70)}%' for i in range(40, 91, 1)]

            for s in SO2:
                error_dict[str(round(100*s))] = []

            for batch_idx, (data, target, parameters) in enumerate(train_loader):
                data, target = data.to(torch.float32).cuda(
                ), target.to(torch.float32).cuda()

                if t == 'Reflectance':
                    data[:, :80] = data[:, :80]*factor
                else:
                    # skin_mus
                    data[:, 80+t_idx*20:80+(t_idx+1)*20] = data[:,
                                                                80+t_idx*20:80+(t_idx+1)*20]*factor

                output = model(data)
                output = output.view(-1)
                output = output.detach().cpu().numpy()
                target = target.detach().cpu().numpy()
                # y = torch.exp(-output).detach().cpu().numpy()
                # x = torch.exp(-target).detach().cpu().numpy()
                # Absolute error
                error += list(100*(torch.abs((torch.tensor(output) -
                              torch.tensor(target)))).numpy())
                # e = torch.abs((torch.tensor(output)-torch.tensor(target))).max().item()
                # if e*100 > max_error:
                #     max_error = e*100
                # # error += torch.sqrt(torch.square((torch.tensor(output)-torch.tensor(target))).mean()).item()
                # for i in range(target.shape[0]):
                #     error_dict[str(round(100*target[i]))].append(np.square(100*output[i]-100*target[i]))
                #     true_SO2.append(round(100*target[i]))
                #     pred_SO2.append(100*output[i])
                #     error_SO2.append(100*(output[i]-target[i]))

                # plt.plot(target,output, 'r.', markersize=5)
                # plt.plot(target,target,'b')

            error = np.array(error)
            mean.append(np.mean(error))
            std.append(np.std(error))
            # mean_mean[iter_idx] = np.mean(error)
        # mean = np.mean(mean_mean, axis=0)
        # std = np.std(mean_mean, axis=0)
        # mean = np.array(mean)
        # std = np.array(std)
        plt.plot(plot_error_test, mean,
                 label=f'{t}', color=cm.rainbow(t_idx/len(tissue)))
        plt.plot(plot_error_test, mean, 'o',
                 color=cm.rainbow(t_idx/len(tissue)))
        # plt.fill_between(plot_error_test, np.array(mean)+np.array(std), np.array(mean)-np.array(std),alpha=0.1, color=cm.rainbow(t_idx/len(tissue)))
        # plt.ylim([0, max(mean+std)])

    plt.title("parameter variation abs error with fixed noise")
    # plt.title("parameter variation abs error with random noise")
    # plt.xticks(SO2, SO2_text)
    # plt.yticks(SO2, SO2_text)
    plt.xlabel("parameter with fixed noised (%)")
    # plt.xlabel("parameter with random noise (%)")
    plt.ylabel("Absolute Error (%)")
    plt.legend()
    plt.savefig(os.path.join(
        "pic", f"{local_time}", "all_randnoise_variation_AbsError.png"))
    plt.show()


# %%
if __name__ == "__main__":
    seconds = time.time()
    local_time = time.ctime(seconds)
    train_loader = torch.load("test_loader.pth")

    # train model
    model = ANN().cuda()

    # input_names = ['delta_log_RMAX_RMIN']
    # output_names = ['delta SO2']
    # input_tensor = torch.tensor(np.random.rand(20)).to(torch.float32).cuda()
    # torch.onnx.export(model,input_tensor, 'ANN.onnx', input_names=input_names, output_names=output_names)

    # plot result
    with open('trlog.pkl', 'rb') as f:
        trlog = pickle.load(f)
    min_loss = min(trlog['test_loss'])
    ep = trlog['test_loss'].index(min_loss)
    model = ANN().cuda()
    # model.load_state_dict(torch.load(f"ep_{ep}_loss_{min_loss}.pth"))
    model.load_state_dict(torch.load("ep_949_loss_0.00016349506972111069.pth"))

    with open("mus_bound.json", "r") as f:
        mus_bound = json.load(f)
    with open("mua_bound.json", "r") as f:
        mua_bound = json.load(f)

    pred()
